#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include "common.h"

#ifndef _LINUX_USERFAULTFD_H
#define _LINUX_USERFAULTFD_H

#define UFFD_API ((u64)0xAA)
#define UFFD_API_REGISTER_MODES (UFFDIO_REGISTER_MODE_MISSING |    \
                 UFFDIO_REGISTER_MODE_WP |    \
                 UFFDIO_REGISTER_MODE_MINOR)
#define UFFD_API_FEATURES (UFFD_FEATURE_PAGEFAULT_FLAG_WP |    \
               UFFD_FEATURE_EVENT_FORK |        \
               UFFD_FEATURE_EVENT_REMAP |        \
               UFFD_FEATURE_EVENT_REMOVE |        \
               UFFD_FEATURE_EVENT_UNMAP |        \
               UFFD_FEATURE_MISSING_HUGETLBFS |    \
               UFFD_FEATURE_MISSING_SHMEM |        \
               UFFD_FEATURE_SIGBUS |        \
               UFFD_FEATURE_THREAD_ID |        \
               UFFD_FEATURE_MINOR_HUGETLBFS |    \
               UFFD_FEATURE_MINOR_SHMEM)
#define UFFD_API_IOCTLS                \
    ((u64)1 << _UFFDIO_REGISTER |        \
     (u64)1 << _UFFDIO_UNREGISTER |    \
     (u64)1 << _UFFDIO_API)
#define UFFD_API_RANGE_IOCTLS            \
    ((u64)1 << _UFFDIO_WAKE |        \
     (u64)1 << _UFFDIO_COPY |        \
     (u64)1 << _UFFDIO_ZEROPAGE |        \
     (u64)1 << _UFFDIO_WRITEPROTECT |    \
     (u64)1 << _UFFDIO_CONTINUE)
#define UFFD_API_RANGE_IOCTLS_BASIC        \
    ((u64)1 << _UFFDIO_WAKE |        \
     (u64)1 << _UFFDIO_COPY |        \
     (u64)1 << _UFFDIO_CONTINUE)

/*
 * Valid ioctl command number range with this API is from 0x00 to
 * 0x3F.  UFFDIO_API is the fixed number, everything else can be
 * changed by implementing a different UFFD_API. If sticking to the
 * same UFFD_API more ioctl can be added and userland will be aware of
 * which ioctl the running kernel implements through the ioctl command
 * bitmask written by the UFFDIO_API.
 */
#define _UFFDIO_REGISTER        (0x00)
#define _UFFDIO_UNREGISTER        (0x01)
#define _UFFDIO_WAKE            (0x02)
#define _UFFDIO_COPY            (0x03)
#define _UFFDIO_ZEROPAGE        (0x04)
#define _UFFDIO_WRITEPROTECT        (0x06)
#define _UFFDIO_CONTINUE        (0x07)
#define _UFFDIO_API            (0x3F)

/* userfaultfd ioctl ids */
#define UFFDIO 0xAA
#define UFFDIO_API        _IOWR(UFFDIO, _UFFDIO_API,    \
                      struct uffdio_api)
#define UFFDIO_REGISTER        _IOWR(UFFDIO, _UFFDIO_REGISTER, \
                      struct uffdio_register)
#define UFFDIO_UNREGISTER    _IOR(UFFDIO, _UFFDIO_UNREGISTER,    \
                     struct uffdio_range)
#define UFFDIO_WAKE        _IOR(UFFDIO, _UFFDIO_WAKE,    \
                     struct uffdio_range)
#define UFFDIO_COPY        _IOWR(UFFDIO, _UFFDIO_COPY,    \
                      struct uffdio_copy)
#define UFFDIO_ZEROPAGE        _IOWR(UFFDIO, _UFFDIO_ZEROPAGE,    \
                      struct uffdio_zeropage)
#define UFFDIO_WRITEPROTECT    _IOWR(UFFDIO, _UFFDIO_WRITEPROTECT, \
                      struct uffdio_writeprotect)
#define UFFDIO_CONTINUE        _IOWR(UFFDIO, _UFFDIO_CONTINUE,    \
                      struct uffdio_continue)

/* read() structure */
struct uffd_msg {
    u8    event;

    u8    reserved1;
    u16    reserved2;
    u32    reserved3;

    union {
        struct {
            u64    flags;
            u64    address;
            union {
                u32 ptid;
            } feat;
        } pagefault;

        struct {
            u32    ufd;
        } fork;

        struct {
            u64    from;
            u64    to;
            u64    len;
        } remap;

        struct {
            u64    start;
            u64    end;
        } remove;

        struct {
            /* unused reserved fields */
            u64    reserved1;
            u64    reserved2;
            u64    reserved3;
        } reserved;
    } arg;
} __packed;

/*
 * Start at 0x12 and not at 0 to be more strict against bugs.
 */
#define UFFD_EVENT_PAGEFAULT    0x12
#define UFFD_EVENT_FORK        0x13
#define UFFD_EVENT_REMAP    0x14
#define UFFD_EVENT_REMOVE    0x15
#define UFFD_EVENT_UNMAP    0x16

/* flags for UFFD_EVENT_PAGEFAULT */
#define UFFD_PAGEFAULT_FLAG_WRITE    (1<<0)    /* If this was a write fault */
#define UFFD_PAGEFAULT_FLAG_WP        (1<<1)    /* If reason is VM_UFFD_WP */
#define UFFD_PAGEFAULT_FLAG_MINOR    (1<<2)    /* If reason is VM_UFFD_MINOR */

struct uffdio_api {
    /* userland asks for an API number and the features to enable */
    u64 api;
#define UFFD_FEATURE_PAGEFAULT_FLAG_WP        (1<<0)
#define UFFD_FEATURE_EVENT_FORK            (1<<1)
#define UFFD_FEATURE_EVENT_REMAP        (1<<2)
#define UFFD_FEATURE_EVENT_REMOVE        (1<<3)
#define UFFD_FEATURE_MISSING_HUGETLBFS        (1<<4)
#define UFFD_FEATURE_MISSING_SHMEM        (1<<5)
#define UFFD_FEATURE_EVENT_UNMAP        (1<<6)
#define UFFD_FEATURE_SIGBUS            (1<<7)
#define UFFD_FEATURE_THREAD_ID            (1<<8)
#define UFFD_FEATURE_MINOR_HUGETLBFS        (1<<9)
#define UFFD_FEATURE_MINOR_SHMEM        (1<<10)
    u64 features;

    u64 ioctls;
};

struct uffdio_range {
    u64 start;
    u64 len;
};

struct uffdio_register {
    struct uffdio_range range;
#define UFFDIO_REGISTER_MODE_MISSING    ((u64)1<<0)
#define UFFDIO_REGISTER_MODE_WP        ((u64)1<<1)
#define UFFDIO_REGISTER_MODE_MINOR    ((u64)1<<2)
    u64 mode;

    /*
     * kernel answers which ioctl commands are available for the
     * range, keep at the end as the last 8 bytes aren't read.
     */
    u64 ioctls;
};

struct uffdio_copy {
    u64 dst;
    u64 src;
    u64 len;
#define UFFDIO_COPY_MODE_DONTWAKE        ((u64)1<<0)
    /*
     * UFFDIO_COPY_MODE_WP will map the page write protected on
     * the fly.  UFFDIO_COPY_MODE_WP is available only if the
     * write protected ioctl is implemented for the range
     * according to the uffdio_register.ioctls.
     */
#define UFFDIO_COPY_MODE_WP            ((u64)1<<1)
    u64 mode;

    /*
     * "copy" is written by the ioctl and must be at the end: the
     * copy_from_user will not read the last 8 bytes.
     */
    s64 copy;
};

struct uffdio_zeropage {
    struct uffdio_range range;
#define UFFDIO_ZEROPAGE_MODE_DONTWAKE        ((u64)1<<0)
    u64 mode;
    s64 zeropage;
};

struct uffdio_writeprotect {
    struct uffdio_range range;
#define UFFDIO_WRITEPROTECT_MODE_WP        ((u64)1<<0)
#define UFFDIO_WRITEPROTECT_MODE_DONTWAKE    ((u64)1<<1)
    u64 mode;
};

struct uffdio_continue {
    struct uffdio_range range;
#define UFFDIO_CONTINUE_MODE_DONTWAKE        ((u64)1<<0)
    u64 mode;
    s64 mapped;
};

/*
 * Create a userfaultfd that can handle page faults only in user mode.
 */
#define UFFD_USER_MODE_ONLY 1

#endif /* _LINUX_USERFAULTFD_H */



typedef void (*racehandler_func)();
typedef struct {
    int uffd;
    void* race_page;
    racehandler_func func;

} racer_arg_t;
int racer(void *arg) {
    struct uffd_msg uf_msg;
    
    int uffd = ((racer_arg_t*)arg)->uffd;
    void* race_page = ((racer_arg_t*)arg)->race_page;
    racehandler_func handle_race = ((racer_arg_t*)arg)->func;
    free(arg);

    struct pollfd pollfd = { .fd = uffd, .events = POLLIN };

    while (poll(&pollfd, 1, -1) > 0) {
        if (pollfd.revents & POLLERR || pollfd.revents & POLLHUP) {
            fatal("poll");
        }
        if (read(uffd, &uf_msg, sizeof(uf_msg)) == 0) {
            fatal("read");
        }
        if (uf_msg.event != UFFD_EVENT_PAGEFAULT) {
            fatal("unexpected pagefault");
        }

        char uf_buffer[0x1000];

        printf("faulting here: %p\n", race_page);
        handle_race(uf_buffer);

        struct uffdio_copy uf_copy = {
            .src = (u64) uf_buffer,
            .dst = (u64) race_page,
            .len = 0x1000, .mode = 0, .copy = 0
        };
        if (ioctl(uffd, UFFDIO_COPY, (unsigned long)&uf_copy) == -1) {
            fatal("UFFDIO_COPY");
        }

        struct uffdio_range uf_range = {
            .start = (u64) race_page, .len = 0x1000
        };
        if (ioctl(uffd, UFFDIO_UNREGISTER, (unsigned long)&uf_range) == -1) {
            perror("UFFDIO_UNREGISTER");
        }
        if (munmap(race_page, 0x1000) == -1) {
            perror("munmap");
        }

        return 0;
    }
    return 0;
}

int register_userfault(void* race_page, racehandler_func func) {
    int uffd;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd < 0) {
        fatal("userfaultfd");
    }

    struct uffdio_api uf_api = { .api = UFFD_API, .features = 0 };
    if (ioctl(uffd, UFFDIO_API, (unsigned long)&uf_api) == -1) {
        fatal("UFFDIO_API failed");
    }

    if (mmap(race_page, 0x1000, PROT_WRITE | PROT_READ, MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED, 0, 0) != (void *)race_page) {
        fatal("mmap failed");
    }

    struct uffdio_register uf_register = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = (u64) race_page,
            .len = 0x1000
        }
    };

    if (ioctl(uffd, UFFDIO_REGISTER, (unsigned long)&uf_register) == -1) {
        fatal("UFFDIO_REGISTER failed");
    }

    void *stack = malloc(0x8000);    // Stack for new process
    if(!stack) {
            fatal("Malloc Failed");
    }

    racer_arg_t *racer_arg = malloc(sizeof(racer_arg_t));
    racer_arg->uffd = uffd;
    racer_arg->race_page = race_page;
    racer_arg->func = func;

    int pid = clone(&racer, (char *)stack + 0x8000, CLONE_VM | CLONE_FILES, racer_arg);
    if( pid < 0 ){
            fatal("Clone Failed");
    }
    return pid;
}

/*
Example use:

void handle_userfault (void* uf_buffer) {
    printf("Handle userfaultfd!\n");
}

...

    register_userfault((void*)0xbaad0000, handle_userfault);
*/
