import os
import re
import shutil
import subprocess

import argparse
import threading

import libarchive
from typing import Optional

from .utils import get_file, info, error, debug, unparameterize, TEMPLATES_DIR
from .runfile import RunFile


def get_ko_file(cpio: str) -> Optional[str]:
    """
    Extract .ko file from CPIO file if necessary
    """
    ko_file = get_file('*.ko')
    if ko_file:
        return ko_file

    with libarchive.Archive(cpio) as a:
        for entry in a:
            if entry.pathname.endswith(".ko") and not re.match(r'lib/modules/[^/]+/kernel/', entry.pathname):
                filename = os.path.basename(entry.pathname)
                with open(filename, 'wb') as f:
                    f.write(a.read(entry.size))
                return f"./{filename}"


def create_files(runfile: RunFile, args: argparse.Namespace):
    """
    Create template files
    """
    if args.no_files:
        return

    try:
        os.mkdir("kernelinit")
    except OSError:
        pass

    with open('./kernelinit/my-run.sh', 'w') as f:
        print("#!/bin/sh", file=f)
        print("# Generated by kernelinit", file=f)
        cpio = 'kernelinit/my-rootfs.cpio' + ('.gz' if runfile.initrd_gzipped else '')
        print(unparameterize(runfile.create_debug_run(cpio), pretty=True), file=f)
    os.chmod('./kernelinit/my-run.sh', 0o775)

    initrd = runfile.args.initrd
    if runfile.initrd_gzipped:
        subprocess.check_output(["gunzip", "-fk", "--", runfile.args.initrd])
        initrd = shutil.move(runfile.args.initrd.replace(".gz", ""), "kernelinit/")
    with open('./kernelinit/debug.gdb', 'w') as f:
        print("# Generated by kernelinit", file=f)
        print("target remote :1234", file=f)
        if not args.no_vmlinux:
            print('add-symbol-file vmlinux', file=f)
        print('add-symbol-file kernelinit/exploit', file=f)
        ko_file = get_ko_file(runfile.args.initrd)
        if ko_file:
            print(f"add-symbol-file {ko_file} 0xffffffffc0000000", file=f)
        print('add-symbol-file kernelinit/kernelsymbols.o', file=f)
        print('set exception-verbose on', file=f)

    open('./kernelinit/kernelconfig.h', 'a').close()

    with open(os.path.join(TEMPLATES_DIR, 'Makefile'), 'r') as f:
        makefile = f.read().replace("CPIOFILE", initrd) \
                           .replace("TEMPLATES_DIR", TEMPLATES_DIR)
        if runfile.initrd_gzipped:
            makefile = makefile.replace("#gzip", "gzip")
    with open('./Makefile', 'w') as f:
        f.write(makefile)

    try:
        shutil.copytree(os.path.join(TEMPLATES_DIR, 'exploit-src'), './exploit-src')
    except OSError:
        error("'exploit-src' already exists. Skipping...")

    try:
        shutil.copy(os.path.join(TEMPLATES_DIR, 'makeroot'), './kernelinit/makeroot')
    except OSError:
        pass

    if not args.no_vmlinux:
        threading.Thread(target=extract_vmlinux, args=(runfile,)).start()


def extract_vmlinux(runfile: RunFile):
    """
    Run vmlinux-to-elf to extract vmlinux with symbols
    This takes time, so run in separate thread.
    """
    if os.path.exists("vmlinux"):
        shutil.move("vmlinux", "vmlinux - backup")

    info("Extracting vmlinux...")
    out = b''
    try:
        out = subprocess.run(['vmlinux-to-elf', '--arch', runfile.arch, '--', runfile.args.kernel, 'vmlinux'],
                                      stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout
    except FileNotFoundError:
        error("Missing vmlinux-to-elf in PATH")

    if b'Successfully wrote the new ELF kernel' in out:
        info('Successfully extracted vmlinux')
    else:
        error('Failed extracting vmlinux using vmlinux-to-elf')
        if out:
            debug("vmlinux-to-elf output:\n" + out.decode())
        out = subprocess.check_output([os.path.join(TEMPLATES_DIR, "..", "extract-vmlinux"), runfile.args.kernel])
        with open('vmlinux', 'wb') as f:
            f.write(out)
        info("Successfully extracted vmlinux using extract-vmlinux")

    inspect_kernel_config()


def inspect_kernel_config():
    """
    Extract certain kernel config settings based on symbols in vmlinux
    """
    out = subprocess.check_output(["nm", "-a", 'vmlinux'], stderr=subprocess.DEVNULL).decode().strip()
    if len(out) < 1000:
        error("No symbols in vmlinux")
        return

    out = [i.split() for i in out.split("\n")]

    symbols = {i[-1].rsplit('.', 1)[0]: int(i[0], 16) if len(i[0]) == 16 else 0 for i in out}

    config = {}

    # Get config options based on presence of symbols
    interesting_symbols = [
        (('init_cred',), False, True, 'KALLSYMS_ALL disabled', 'KALLSYMS_ALL'),
        (('handle_userfault',), False, False, 'USERFAULTFD enabled', 'USERFAULTFD'),
        (('fuse_do_open',), False, False, 'FUSE_FS enabled', 'FUSE_FS'),
        (('bpf_ksym_add',), False, False, 'BPF_JIT enabled', 'BPF_JIT'),
        (('ksys_msgget',), False, True, 'msg_msg not available', 'SYSVIPC'),
        (('user_preparse',), False, True, 'user_key_payload not available', 'KEYS'),
        (('nft_do_chain',), False, False, 'NF_TABLES enabled', 'NF_TABLES'),
        (('make_kuid',), False, False, 'USER_NS enabled', 'USER_NS'),
        (('__kasan_kmalloc',), False, False, 'KASAN enabled', 'KASAN'),
        (('kasan_cache_create',), False, False, None, 'KASAN_GENERIC'),
        (('__kfence_pool',), False, False, 'KFENCE enabled', 'KFENCE'),
        (('pti_check_boottime_disable',), False, True, 'PTI disabled', 'PAGE_TABLE_ISOLATION'),
        (('kaslr_get_random_long',), False, True, 'KASLR disabled', 'RANDOMIZE_BASE'),
        (('__stack_chk_fail',), False, True, 'No Stack Canary', 'STACKPROTECTOR'),
        (('init_shadow_call_stack',), False, False, 'Shadow stack enabled', 'SHADOW_CALL_STACK'),
        (('handle_cfi_failure',), False, False, 'kCFI enabled', 'CFI_CLANG'),
        (('mod_objcg_state',), False, False, 'kmalloc-cg- enabled', 'MEMCG_KMEM'),
        (('random_kmalloc_seed',), False, False, 'kmalloc-rnd- enabled', 'RANDOM_KMALLOC_CACHES'),
        (('usercopy_abort',), False, False, 'HARDENED_USERCOPY enabled', 'HARDENED_USERCOPY'),
        (('__list_add_valid_or_report',), False, False, 'LIST_HARDENED enabled', 'LIST_HARDENED'),
        (('init_cache_random_seq',), False, False, 'SLAB_FREELIST_RANDOM enabled', 'SLAB_FREELIST_RANDOM'),
        ((), False, False, None, 'SLAB_FREELIST_HARDENED'),  # Can't be detected this way
        (('flushwq',), True, False, None, 'SLUB_TINY'),
        (('slub_set_cpu_partial', 'put_cpu_partial',), False, False, None, 'SLUB_CPU_PARTIAL'),
        (('vma_ra_enabled_show',), False, False, None, 'SYSFS'),
        (('node_reclaim',), False, False, None, 'NUMA'),
        (('__fill_map', 'dump_unreclaimable_slab'), False, False, None, 'SLUB_DEBUG'),
        (('memcg_to_vmpressure',), False, False, None, 'MEMCG'),
        (('kunmap_high',), False, False, None, 'HIGHMEM'),
        (('smpcfd_prepare_cpu',), False, False, None, 'SMP'),
    ]

    for targets, invert, msg_invert, msg, config_name in interesting_symbols:
        is_enabled = any(i in symbols for i in targets) ^ invert
        if msg is not None and is_enabled ^ msg_invert:
            info(f"CONFIG: {msg}")
        config[config_name] = is_enabled


    # Get config options based on size of symbols
    def get_symbol_size(name):
        if name not in symbols:
            return None
        addr = symbols[name]
        next_addr = 2**64-1
        for i in symbols.values():
            if i > addr and i < next_addr:
                next_addr = i
        return next_addr - addr

    config['MAXSMP'] = (get_symbol_size('__per_cpu_offset') or 0) > 0x200

    if config['NUMA']:
        config['NODES_SHIFT'] = 10 if config['MAXSMP'] else 6
    else:
        config['NODES_SHIFT'] = False

    if config['SMP']:
        config['NR_CPUS_DEFAULT'] = 8192 if config['MAXSMP'] else 64
    else:
        config['NR_CPUS_DEFAULT'] = 1

    # Assume always set
    config['X86_64'] = True
    config['X86_VMX_FEATURE_NAMES'] = True
    config['MMU'] = True

    # Get config options from disassembly
    def gdb_exec(cmd):
        try:
            out = subprocess.check_output(['gdb', '-batch',
                                           '-ex', 'file vmlinux',
                                           '-ex', 'set disassembly-flavor intel',
                                           '-ex', cmd],
                                           stderr=subprocess.DEVNULL).decode()
        except Exception as e:
            error(str(e))
            out = ""
        return out

    for sym in ('__kmem_cache_create', 'kmem_cache_open'):
        if sym not in symbols:
            continue
        out = gdb_exec(f'disassemble {sym}')
        if 'get_random' in out:
            config['SLAB_FREELIST_HARDENED'] = True
            info(f"CONFIG: SLAB_FREELIST_HARDENED enabled")

    if 'call_usermodehelper_setup' in symbols:
        out = gdb_exec('disass call_usermodehelper_setup')
        if m := re.search(r'\[r..?\+0x28\],\s*(0x[0-9a-f]+)', out):
            config['STATIC_USERMODEHELPER'] = True
            info(f"CONFIG: STATIC_USERMODEHELPER enabled")
            if m := re.search(r'0x[0-9a-f]+:\s*"(.*)"', gdb_exec(f'x/s {m[1]}')):
                config['STATIC_USERMODEHELPER_PATH'] = f'"{m[1]}"'

    # Create config
    config_str = "// Generated by kernelinit\n"

    if 'linux_banner' in symbols:
        if m := re.search(r'0x[0-9a-f]+:\s*"Linux[\sA-Za-z]+([0-9]+)\.([0-9]+)', gdb_exec(f'x/s &linux_banner')):
            version = int(m[1]) * 1000 + int(m[2])
            config_str += f'#define KERNEL_VERSION {version}\n'

    for name, value in config.items():
        if value is True:
            config_str += f"#define CONFIG_{name}\n"
        elif value is False:
            config_str += f"//#define CONFIG_{name}\n"
        else:
            config_str += f"#define CONFIG_{name} {value}\n"

    with open('kernelinit/kernelconfig.h', 'w') as f:
        f.write(config_str)

def cleanup_files():
    """
    Remove files that were previously generated by kernelinit
    """
    def try_remove(filename):
        try:
            os.remove(filename)
        except OSError as e:
            debug(f'Failed to remove {repr(filename)}: {e.strerror}')

    def delete_safe(filename):
        if not os.path.isfile(filename):
            return
        with open(filename, 'r') as f:
            s = f.read()
        if 'Generated by kernelinit' in s:
            try_remove(filename)
        else:
            debug(f"Did not remove {repr(filename)}. Missing signature")

    try:
        subprocess.check_output(['make', 'clean'], stderr=subprocess.PIPE)
    except (OSError, subprocess.CalledProcessError):
        pass
    if os.path.exists('./kernelinit/my-run.sh'):
        shutil.rmtree('./kernelinit')
    delete_safe('./Makefile')

    if os.path.exists('./exploit-src'):
        try:
            subprocess.check_output(['diff', os.path.join(TEMPLATES_DIR, './exploit-src/'), 'exploit-src'], stderr=subprocess.PIPE)
        except subprocess.CalledProcessError:
            try:
                line = input("exploit-src differs from template. Delete anyways? [y/N] ")
            except EOFError:
                return
            if not line.lower().startswith("y"):
                return
        shutil.rmtree('./exploit-src')
